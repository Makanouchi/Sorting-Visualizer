import random
import time
import matplotlib.pyplot as plt  # importing the entire module pyplot of package matplotlib , now plt is will act as an object
import matplotlib.animation as animation

def bubble_sort(A):
    """In-place sorting"""

    flag=1 #this variable is for in case array already gets sorted in the middle we don't need to carry on
    for length in range(len(A), 0, -1):
        if flag == 0:
            return

        flag=0
        for i in range(length-1):
            if A[i] > A[i + 1]:
                flag=1
                A[i],A[i+1]=A[i+1],A[i]
            yield A
# def selection_sort(A):
#
# def merge_sort(A,l,r):
#
# def merge(A,l1,r1,l2,r2):
# def quick_sort(A,l,r):
# def insertion_sort(A):


if __name__=="__main__":  #if __name__ == “main”: is used to execute some code only if the file was run directly, and not imported.
                        # __name__ is a variable which python interpreter initializes and if the module is run directly then it is initialized
                        # the value "main" otherwise when this module is imported then this variable will be initialized by the moudle name.

    #taking inputs
    N=int(input("Enter the number of values\n"))
    msg="Enter the sorting algorithm you want to apply\n b for Bubble Sort\n i for Insertion Sort\n m for Merge Sort\n s for Selection Sort\n q for Quick Sort\n"
    sort_type=input(msg)

    #making our random array
    A=[x+1 for x in range(N)]
    random.seed(time.time())
    random.shuffle(A)

    if sort_type=='b':
        title="Bubble Sort"
        generator =bubble_sort(A)

    # elif sort_type=='i':
    #     title="Insertion Sort"
    #     generator =insertion_sort(A)
    #
    # elif sort_type=='m':
    #     title="Merge Sort"
    #     generator =merge_sort(A)
    #
    # elif sort_type=='s':
    #     title="Selection Sort"
    #     generator =selection_sort(A)
    #
    # elif sort_type=='q':
    #     title="Quick Sort"
    #     generator =quick_sort(A)

    fig , ax=plt.subplots(1,1) #this means i need only 1*1=1 plot in the figure.
    ax.set_title(title)

    #setting the xlimits and y limits
    ax.set_xlim(0,N)
    ax.set_ylim(0,1.10*N)

    #ax.bar() will return me list of bar objects on my plot , and I can refer to each bar and change it on my will
    bar_objs=ax.bar(range(len(A)),A,align="edge")

    #setting the color of all bar objects
    for i in range(len(A)):
        bar_objs[i].set_color('y')

    #reserving the position for "# of operations: " tag which will get updated in each frame
    #transform=ax.transAxes this is referring to (0,0) as the left bottom and (1,1) as the upper right corner so we can easily write the coordinates
    Optext= ax.text(0.03,0.94,"# of operation: 0",transform=ax.transAxes)

    cnt=0 #the number of operations

    #this function will update the plt for each frame, it will change the height of the bars and also the "# of operations: " label
    def updation_func(A,bars):
        for i in range(len(A)):
            bars[i].set_height(A[i])
        global cnt
        cnt +=1
        Optext.set_text("# of operations: {}".format(cnt))

    # func - function which updates each frame,it takes the data generated by generator as its first argument
    # frame- generates source of data for each frame of animation, this data is the first argument of func.
    # fargs- the rest of the arguments of func
    # interval- how many millisecond delay b/w each frame
    anim=animation.FuncAnimation(fig,func=updation_func,fargs=(bar_objs,),frames=generator,interval=2,repeat=False)

    plt.show()


